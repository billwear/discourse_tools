#!/usr/bin/python3

import argparse
import sys, subprocess, json, os, time
from yaml import load, dump      
try:                             
    from yaml import CLoader as Loader, CDumper as Dumper
except ImportError:
    from yaml import Loader, Dumper

from menutree import setmenu

def push_discourse():
    try:
        file = str(args.file[0])
    except:
        pass
    try:
        config = str(args.config[0])
    except:
        config = "/etc/dc.yaml"

    # read config file to get api-key, api-usr, and discourse url
    cfile = open("/etc/dc.yaml","r")
    config_data = load(cfile, Loader=Loader)
    cfile.close();

    if(args.new):

        # check a couple of required options
        if(args.cat == None):
            print('no category entered: use "-k" to specify category for new topic')
            sys.exit()
        if(args.title == None):
            print('no title entered: use "-T" to specify title for new topic')
            sys.exit()
            
        # switch in conditional sections based on tags
        if(args.tags):
            condfile = "cond_"+file
            tag_count = len(args.tags)
            for x in range(tag_count):
                grepcli = 'grep -v "<!--[ ]*' + str(args.tags[x]) + '" '
                grepcli += file + ' | grep -v '
                grepcli += '"' + str(args.tags[x]) + '[ ]*-->" >> '
                grepcli += condfile
                os.system(grepcli)
                cpcli = "cp " + condfile + " tmp.md"
                os.system(cpcli)
                file = "tmp.md"
    
            file = "tmp.md"
            os.system("rm " + condfile)

                
        # load and convert the specified markdown file
        f = open(file, "r")
        markdown = f.read()
                
        # pad the markdown to 9000 chars to avoid discourse bug
        outstr = markdown.ljust(9000)
        
        # create a dictionary buffer for the markdown
        data = {}
        
        # place the markdown in the appropriate json keys
        data["title"] = str(args.title[0])
        data["category"] = args.cat[0]
        data["raw"] = outstr
        
        # open a temporary json file to store the markdown as json
        f = open("foo.json", "w")
        
        # convert the markdown to json and store it in the temp file
        f.write(json.dumps(data))
        
        # close the temp file for completeness
        f.close()
        
        # set the url and auth data as read from the yaml config file
        url = config_data['base_url'] + '/posts.json'
        apikey = 'Api-Key: ' + config_data['api_key']
        apiusername = 'Api-Username: ' + config_data['api_username']
    
        # use the curl command to re-post the markdown into discourse
        response = subprocess.check_output([
            'curl',
            '-X',
            'POST',
            url,
            '-H',
            apikey,
            '-H',
            apiusername,
            '-H',
            'Content-Type: application/json',
            '-d',
            '@foo.json']
        )

        # remove the temporary files
        os.remove("foo.json")

    elif( args.all and args.bulk ): # push a whole set, using filenames to place

        # the for loop to get all *.md files
        directory = "."
        topic = 0
        
        for mdfilename in os.listdir(directory):

            # get the topic number from the filename
            if(mdfilename.endswith(".md")):
               flist = mdfilename.split('-')
               fl2 = flist[-1].split('.')
               if(fl2[0].isnumeric()):
                   topic = int(fl2[0])
               else:
                   continue
            else:
                continue

            file = mdfilename
            
            # switch in conditional sections based on tags
            if(args.tags):
                condfile = "cond_"+file
                tag_count = len(args.tags)
                for x in range(tag_count):
                    grepcli = 'grep -v "<!--[ ]*' + str(args.tags[x]) + '" '
                    grepcli += file + ' | grep -v '
                    grepcli += '"' + str(args.tags[x]) + '[ ]*-->" >> '
                    grepcli += condfile
                    os.system(grepcli)
                    cpcli = "cp " + condfile + " tmp.md"
                    os.system(cpcli)
                    file = "tmp.md"
    
                file = "tmp.md"
                os.system("rm " + condfile)
        
            # run the shell command to get the topic and retain the result
            proc = subprocess.Popen([
                'curl',
                '-X',
                'GET',
                '-H',
                'Api-Key: ' + config_data['api_key'],
                '-H',
                'Api-Username: ' + config_data['api_username'],
                '-H',
                'Content-Type: application/json',
                config_data['base_url'] + '/t/{'+str(topic)+'}.json'],
                                    stdout=subprocess.PIPE
            )

            # read the result into a usable buffer
            output = proc.stdout.read()
            
            # convert the result to json
            try:
                topic_json = json.loads(output)
            except:
                print("topic " + str(topic) + " doesn't exist; exiting")
                sys.exit(4)

            # extract the post ID from the topic json
            post_id = topic_json['post_stream']['posts'][0]['id']
            category_id = topic_json['category_id']
            deleted_at = topic_json['deleted_at']
            if(deleted_at and args.nodeleted):
                print("post deleted: not pushed from discourse")
                sys.exit()

            autoname = topic_json['post_stream']['posts'][0]['topic_slug'] + \
                '-' + str(topic) + '.md'

            outfile_name = file
    
            # load and convert the specified markdown file
            f = open(outfile_name, "r")
            markdown = f.read()

            # pad the markdown to 9000 chars to avoid discourse bug
            outstr = markdown.ljust(9000)
        
            # create a dictionary buffer for the markdown
            data = {}
        
            # place the markdown against a key called "raw" discourse)
            data["raw"] = outstr
        
            # open a temporary json file to store the markdown as json
            f = open("foo.json", "w")
        
            # convert the markdown to json and store it in the temp file
            f.write(json.dumps(data))
        
            # close the temp file for completeness
            f.close()
        
            # set the url and auth data as read from the yaml config file
            url = config_data['base_url'] + '/posts/{'+str(post_id)+'}.json'
            apikey = 'Api-Key: ' + config_data['api_key']
            apiusername = 'Api-Username: ' + config_data['api_username']
    
            # use the curl command to re-post the markdown into discourse
            response = subprocess.check_output([
                'curl',
                '-X',
                'PUT',
                url,
                '-H',
                apikey,
                '-H',
                apiusername,
                '-H',
                'Content-Type: application/json',
                '-d',
                '@foo.json']
            )

            # remove the temporary json file
            os.remove("foo.json")

    else: # just pushing one existing topic back to discourse
        # run the shell command to get the topic and retain the result
        topic = args.topic[0]
        proc = subprocess.Popen([
            'curl',
            '-X',
            'GET',
            '-H',
            'Api-Key: ' + config_data['api_key'],
            '-H',
            'Api-Username: ' + config_data['api_username'],
            '-H',
            'Content-Type: application/json',
            config_data['base_url'] + '/t/{'+str(topic)+'}.json'],
                                stdout=subprocess.PIPE
        )

        # read the result into a usable buffer
        output = proc.stdout.read()

        # convert the result to json
        try:
            topic_json = json.loads(output)
        except:
            print("topic " + str(topic) + " doesn't exist; exiting")
            sys.exit(4)

        # extract the post ID from the topic json
        post_id = topic_json['post_stream']['posts'][0]['id']
        category_id = topic_json['category_id']
        deleted_at = topic_json['deleted_at']
        if(deleted_at and args.nodeleted):
            print("post deleted: not pushed from discourse")
            sys.exit()

        autoname = topic_json['post_stream']['posts'][0]['topic_slug'] + \
            '-' + str(topic) + '.md'

        # switch in conditional sections based on tags
        if(args.tags):
            condfile = "cond_"+file
            tag_count = len(args.tags)
            for x in range(tag_count):
                grepcli = 'grep -v "<!--[ ]*' + str(args.tags[x]) + '" '
                grepcli += file + ' | grep -v '
                grepcli += '"' + str(args.tags[x]) + '[ ]*-->" >> '
                grepcli += condfile
                os.system(grepcli)
                cpcli = "cp " + condfile + " tmp.md"
                os.system(cpcli)
                file = "tmp.md"
    
            file = "tmp.md"
            os.system("rm " + condfile)
            
        outfile_name = file
    
        # load and convert the specified markdown file
        f = open(outfile_name, "r")
        markdown = f.read()

        # pad the markdown to 9000 chars to avoid discourse bug
        outstr = markdown.ljust(9000)
        
        # create a dictionary buffer for the markdown
        data = {}
        
        # place the markdown against a key called "raw" (the json key reqd by discourse)
        data["raw"] = outstr
        
        # open a temporary json file to store the markdown as json
        f = open("foo.json", "w")
        
        # convert the markdown to json and store it in the temp file
        f.write(json.dumps(data))
        
        # close the temp file for completeness
        f.close()
        
        # set the url and auth data as read from the yaml config file
        url = config_data['base_url'] + '/posts/{'+str(post_id)+'}.json'
        apikey = 'Api-Key: ' + config_data['api_key']
        apiusername = 'Api-Username: ' + config_data['api_username']
    
        # use the curl command to re-post the markdown into discourse
        response = subprocess.check_output([
            'curl',
            '-X',
            'PUT',
            url,
            '-H',
            apikey,
            '-H',
            apiusername,
            '-H',
            'Content-Type: application/json',
            '-d',
            '@foo.json']
        )

        # remove the temporary json file
        os.remove("foo.json")

def push_github():
    if(args.gitpushall == True):
        response = subprocess.check_output([
            'git',
            'add',
            '.']
        )
        try:
            response = subprocess.check_output([
                'git',
                'commit',
                '-m',
                'bot-push']
            )
        except:
            print("up to date")
            sys.exit()
        response = subprocess.check_output([
            'git',
            'push']
        )            
    else:
        file = str(args.file[0])
        response = subprocess.check_output([
            'git',
            'add',
            file]
        )
        try:
            response = subprocess.check_output([
                'git',
                'commit',
                '-m',
                'bot-push']
            )
        except:
            print("up to date")
            sys.exit()

        response = subprocess.check_output([
            'git',
            'push']
        )

def pull_discourse():
    if(args.range != None):
        start = args.range[0]
        end = args.range[1]
        
        try:
            config = str(args.config[0])
        except:
            config = "/etc/dc.yaml"

        # read config file to get api-key, api-usr, and discourse url
        cfile = open("/etc/dc.yaml","r")
        config_data = load(cfile, Loader=Loader)
        cfile.close();
        
        # giant for loop to get the topic range specified
        for tn in range( start, end+1 ):
            
            # sleep for 2.5 seconds - prevents discourse DDOS rejection
            time.sleep(2.5)
            
            # run the shell command to get the topic and retain the result
            proc = subprocess.Popen([
                'curl',
                '-X',
                'GET',
                '-H',
                'Api-Key: ' + config_data['api_key'],
                '-H',
                'Api-Username: ' + config_data['api_username'],
                '-H',
                'Content-Type: application/json',
                config_data['base_url'] + '/t/{'+str(tn)+'}.json'],
                                    stdout=subprocess.PIPE
            )
            
            # read the result into a usable buffer
            output = proc.stdout.read()
            
            # debug output: what topic were you pulling?
            print("topic = " + str(tn))
                
            # convert the result to json
            try:
                topic_json = json.loads(output)
            except:
                continue
            
            # extract the post ID from the topic json
            post_id = topic_json['post_stream']['posts'][0]['id']
            category_id = topic_json['category_id']
            if(args.cat):
                if((category_id is None)
                   or (int(args.cat[0]) != int(category_id))):
                    continue
            autoname = topic_json['post_stream']['posts'][0]['topic_slug'] + \
                '-' + str(tn) + '.md'
            deleted_at = topic_json['deleted_at']
            if(deleted_at and args.nodeleted):
                print("post deleted: not pulled from discourse")
                continue
            outfile_name = autoname;
                
            # read the post using the api, retaining the return value
            proc2 = subprocess.Popen([
                'curl',
                '-X',
                'GET',
                '-H',
                'Api-Key: ' + config_data['api_key'],
                '-H',
                'Api-Username: ' + config_data['api_username'],
                '-H',
                'Content-Type: application/json',
                config_data['base_url'] + '/posts/{'+str(post_id)+'}.json'],
                                     stdout=subprocess.PIPE
            )
                
            # copy the return value to a suitable buffer
            output2 = proc2.stdout.read()
            
            # convert the returned post to json
            post_json = json.loads(output2)

            # extract the article markdown from the json output
            raw = post_json['raw']
            
            # write the article markdown to the specified file
            f = open(outfile_name, "w")
            f.write(str(raw))
            f.close()
                
        # exit now, as this run is finished
        sys.exit(0)
    else:
        file = str(args.file[0])
        topic = args.topic[0]
        try:
            config = str(args.config[0])
        except:
            config = "/etc/dc.yaml"

        # read config file to get api-key, api-usr, and discourse url
        cfile = open("/etc/dc.yaml","r")
        config_data = load(cfile, Loader=Loader)
        cfile.close();

        # run the shell command to get the topic and retain the result
        proc = subprocess.Popen([
            'curl',
            '-X',
            'GET',
            '-H',
            'Api-Key: ' + config_data['api_key'],
            '-H',
            'Api-Username: ' + config_data['api_username'],
            '-H',
            'Content-Type: application/json',
            config_data['base_url'] + '/t/{'+str(topic)+'}.json'],
                                stdout=subprocess.PIPE
        )

        # read the result into a usable buffer
        output = proc.stdout.read()

        # convert the result to json
        try:
            topic_json = json.loads(output)
        except:
            print("topic " + str(topic) + " doesn't exist; exiting")
            sys.exit(4)


        # extract the post ID from the topic json
        post_id = topic_json['post_stream']['posts'][0]['id']
        category_id = topic_json['category_id']
        deleted_at = topic_json['deleted_at']
        if(deleted_at and args.nodeleted):
            print("post deleted: not pulled from discourse")
            sys.exit()
            
        autoname = topic_json['post_stream']['posts'][0]['topic_slug'] + \
            '-' + str(topic) + '.md'
            
        # compute the output file
        # if(options.autoname):
        #     outfile_name = autoname;
        # else:
        #     outfile_name = options.file
        outfile_name = file
            
        # if user requested the intermediate topic json, specified file
        if(args.topicjson):
            f2 = open("topic.json", "w")
            f2.write(str(topic_json))
            f2.close()
            
        # read the post using the api, retaining the return value
        proc2 = subprocess.Popen([
            'curl',
            '-X',
            'GET',
            '-H',
            'Api-Key: ' + config_data['api_key'],
            '-H',
            'Api-Username: ' + config_data['api_username'],
            '-H',
            'Content-Type: application/json',
            config_data['base_url'] + '/posts/{'+str(post_id)+'}.json'],
                                 stdout=subprocess.PIPE
        )
            
        # copy the return value to a suitable buffer
        output2 = proc2.stdout.read()
            
        # convert the returned post to json
        post_json = json.loads(output2)
            
        # if user req intermediate post json, write it to the specified file
        if( args.postjson ):
            f2 = open("post.json", "w")
            f2.write(str(post_json))
            f2.close()
                
        # extract the article markdown from the json output
        raw = post_json['raw']
            
        # write the article markdown to the specified file
        f = open(outfile_name, "w")
        f.write(str(raw))
        f.close()

def pull_github():
    fileflag = args.gitall
    if(fileflag == True):
        response = subprocess.check_output([
            'git',
            'fetch']
        )
        response = subprocess.check_output([
            'git',
            'checkout',
            'origin/master',
            '--',
            '.']
        )
    else:
        file = str(args.file[0])
        response = subprocess.check_output([
            'git',
            'fetch']
        )
        response = subprocess.check_output([
            'git',
            'checkout',
            'origin/master',
            '--',
            file]
        )

parser = setmenu()
args = parser.parse_args()

if(args.l1 == "push"):
    if(args.push_l2 == "discourse"):
        push_discourse()
    elif(args.push_l2 == "github"):
        push_github()
elif(args.l1 == "pull"):
    if(args.pull_l2 == "discourse"):
        pull_discourse()
    elif(args.pull_l2 == "github"):
        pull_github()
            
