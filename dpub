#!/usr/bin/python3
# dpub is a set of discourse publishing tools, using the discourse API
# try "dpub -h" for help and calling sequences
#
import requests                         # for handling api requests
import subprocess                       # for issuing shell commands
import json                             # for en/decoding json
import sys, os                          # for various uses
import time                             # for sleep() function
from optparse import OptionParser       # for nice, unix-like options
from yaml import load, dump             # for handling yaml config file
try:                                    # also ^^
    from yaml import CLoader as Loader, CDumper as Dumper
except ImportError:
    from yaml import Loader, Dumper

# command line parser setup
parser = OptionParser()

# -a, --autoname: sets get output filename to topic slug + topic number
parser.add_option("-a", "--autoname",action="store_true",dest="autoname", default=False,
                  help="build filename from topic name+number (with -g; ignores -f)")

# -c, --category: restricts get & new operations to a specific category
parser.add_option("-c", "--category", dest="category", 
                  help="only operate on topics in specifed category")

# -f, --file: filename to get into, or filename to put/create from
parser.add_option("-f", "--file", dest="filename",
                  help="file to read (-g) or write (-p, -c)", metavar="FILE")

# -g, --get: pull a topic from discourse
parser.add_option("-g", "--get", action="store_true", dest="get", default=False,
                  help="read TOPIC into FILENAME; req -t & -f")

# -G, --github: pull markdown from github, instead
parser.add_option("-G", "--github", action="store_true", dest="github",
                  default=False,
                  help="use get (-g) or put (-p) to pull from github")

# -k, --config: yaml configuration file with site & auth data
parser.add_option("-k", "--config", dest="config_file",
                  help="config file w/URL, api-key, username (default \"dpub.yaml\")")

# -j, --json: write output post json to file before converting to markdown
parser.add_option("-j", "--json", dest="json_file",
                  help="write post json to JSON_FILE when using -g, before converting")

# -J, --JSON: write output topic json to file before converting to markdown
parser.add_option("-J", "--JSON", dest="topic_json_file",
                  help="write TOPIC json to TOPIC_JSON_FILE when using -g")

# -n, --new: create a new topic
parser.add_option("-n", "--new", action="store_true", dest="new", default=False,
                  help="create new topic from filename")

# -p, --put: put a (probably changed) topic back into discourse
parser.add_option("-p", "--put", action="store_true", dest="put", default=False,
                  help="write TOPIC from FILENAME into discourse; req -t & -f")

# -r, --srange: specify the lowest topic number to bulk get
parser.add_option("-r", "--srange", dest="srange",
                  help="minimum topic number to read (with -g)")

# -R, --erange: specify the highest topic number to bulk get
parser.add_option("-R", "--erange", dest="erange",
                  help="minimum topic number to read (with -g)")

# -t, --topic: specify the topic number to get or put
parser.add_option("-t", "--topic", dest="topic",
                  help="discourse topic to read or write (with -g or -p)")

# -T, --title: specify the title for a new article
parser.add_option("-T", "--title", dest="topic_title",
                  help="title of new discourse topic (with -n)")

# actually parse the incoming args
(options,args) = parser.parse_args()

# if no command was given, notify and stop
if(not options.get and not options.put and not options.new):
    print("you must get (-g), put (-p), or create new (-n)")
    print("fix your mistake and try again, or try -h for help")
    sys.exit()

# if get and put were commanded together, notify and stop    
if(options.get and options.put):
    print("-g (get) and -p (put) are incompatible")
    print("fix your mistake and try again, or try -h for help")
    sys.exit()

# if get and new were commanded together, notify and stop
if(options.get and options.new):
    print("-g (get) and -n (new) are incompatible")
    print("fix your mistake and try again, or try -h for help")
    sys.exit()

# if put and new were commanded together, notify and stop
if(options.put and options.new):
    print("-p (put) and -n (new) are incompatible")
    print("fix your mistake and try again, or try -h for help")
    sys.exit()

# if put was commanded with no topic, notify and stop
if(options.put and not options.topic):
    print("-p (put) requires specifying a topic with -t")
    print("fix your mistake and try again, or try -h for help")
    sys.exit()

# if get was commanded without a topic or a range, notify and stop
if(options.get and not (options.topic or (options.srange and options.erange))):
    print("-g (get) requires a topic (-t) or topic range (-r/R)")
    print("fix your mistake and try again, or try -h for help")
    sys.exit()

# if one end of range was specified without the other, notify and stop
if((options.erange and not options.srange) or (options.srange and not options.erange)):
    print("-r (start range) and -R (end range) are both required for a topic range")
    print("fix your mistake and try again, or try -h for help")
    sys.exit()

# if put was commanded without a filename, notify and stop
if(options.put and not options.github and not options.filename):
    print("-p (put) must have a filename (-f) to put")
    print("fix your mistake and try again, or try -h for help")
    sys.exit()

# if new was specified without a filename, notify and stop
if(options.new and not options.filename):
    print("-n (new) must have a filename (-f) to put")
    print("fix your mistake and try again, or try -h for help")
    sys.exit()

# if new was specified without a title, notify and stop
if(options.new and not options.topic_title):
    print("-n (new) must have a topic title (-T) for new topic")
    print("fix your mistake and try again, or try -h for help")
    sys.exit()

# if get was commanded without a filename or autoname flag, notify and stop
if(options.get and not (options.filename or options.autoname)):
    print("-g (get) must have a filename (-f) to use, or autoname (-a) enabled")
    print("fix your mistake and try again, or try -h for help")
    sys.exit()

# if get was commanded with both a filename and the autoname flag, notify and stop
if(options.get and options.filename and options.autoname):
    print("-g (get) must have either a filename (-f) or autoname (-a); not both")
    print("fix your mistake and try again, or try -h for help")
    sys.exit()

# if put was commanded and autoname was specified, warn -a ignored & continue
if(options.autoname and options.put):
    print("note: -a (autoname) ignored with -p (put)")

# if new was commanded and autoname was specified, warn -a ignored & continue
if(options.autoname and options.new):
    print("note: -a (autoname) ignored with -n (new)")

# if new was commanded and a topic number was given, warn -t ignored & continue
if(options.new and options.topic):
    print("note: -t (topic) ignored with a -n (new)")

# if new was commanded and a range was given, warn -r/R ignored & continue
if(options.new and (options.srange or options.erange)):
    print("note: -r/R (topic range) ignored with a -n (new)")

# if put was commanded and a range was given, warn -r/R ignored & continue
if(options.put and (options.srange or options.erange)):
    print("note: -r/R (topic range) ignored with a -p (put)")

# if config file specified on command line, use that value
if(options.config_file):
    config_file = options.config_file
# otherwise, use the default "/etc/dc.yaml"
else:
    config_file = "/etc/dc.yaml"

# read config file to get api-key, api-usr, and discourse url
cfile = open("/etc/dc.yaml","r")
config_data = load(cfile, Loader=Loader)
cfile.close();

# read a range of posts
if( options.get and options.srange and options.erange ):

    # giant for loop to get the topic range specified
    for tn in range( int(options.srange), int(options.erange) + 1):

        # sleep for 2.5 seconds - prevents discourse DDOS rejection
        time.sleep(2.5)

        # run the shell command to get the topic and retain the result
        proc = subprocess.Popen([
            'curl',
            '-X',
            'GET',
            '-H',
            'Api-Key: ' + config_data['api_key'],
            '-H',
            'Api-Username: ' + config_data['api_username'],
            '-H',
            'Content-Type: application/json',
            config_data['base_url'] + '/t/{'+str(tn)+'}.json'],
                                stdout=subprocess.PIPE
        )

        # read the result into a usable buffer
        output = proc.stdout.read()

        # debug output: what topic were you pulling?
        print("topic = " + str(tn))
        
        # convert the result to json
        try:
            topic_json = json.loads(output)
        except:
            continue
        
        # extract the post ID from the topic json
        post_id = topic_json['post_stream']['posts'][0]['id']
        category_id = topic_json['category_id']
        if(options.category):
            if((category_id is None) or (int(options.category) != int(category_id))):
                continue
        autoname = topic_json['post_stream']['posts'][0]['topic_slug'] + \
            '-' + str(tn) + '.md'
        deleted_at = topic_json['deleted_at']
        if(deleted_at):
            print("post deleted: not pulled from discourse")
            continue
        if(options.autoname):
            outfile_name = autoname;
        else:
            outfile_name = options.filename
        
        # if user requested the intermediate topic json, specified filename
        if( options.topic_json_file ):
            f2 = open(options.topic_json_file, "w")
            f2.write(str(topic_json))
            f2.close()

        # is this a github pull?
        if( options.github ):
            proc = subprocess.Popen([
                'git',
                'fetch',
                '--all'],
                stdout=subprocess.PIPE
            )
            proc = subprocess.Popen([
                'git',
                'checkout',
                'origin/master',
                '--',
                outfile_name],
                stdout=subprocess.PIPE
            )

        else:
            
            # read the post using the api, retaining the return value
            proc2 = subprocess.Popen([
                'curl',
                '-X',
                'GET',
                '-H',
                'Api-Key: ' + config_data['api_key'],
                '-H',
                'Api-Username: ' + config_data['api_username'],
                '-H',
                'Content-Type: application/json',
                config_data['base_url'] + '/posts/{'+str(post_id)+'}.json'],
                                 stdout=subprocess.PIPE
            )
            
            # copy the return value to a suitable buffer
            output2 = proc2.stdout.read()
        
            # convert the returned post to json
            post_json = json.loads(output2)
        
            # if user req intermediate post json, write it to the specified filename
            if( options.json_file ):
                f2 = open(options.json_file, "w")
                f2.write(str(post_json))
                f2.close()

            # extract the article markdown from the json output
            raw = post_json['raw']
            
            # write the article markdown to the specified filename
            f = open(outfile_name, "w")
            f.write(str(raw))
            f.close()
                    
    # exit now, as this run is finished
    sys.exit(0)

# read the topic, which is required for both get and put
# note that discourse *topic* put doesn't work reliably at this time,
# so dpub gets the topic to get the post number, then reads or writes the post
if( options.get or options.put ):
    
    # run the shell command to get the topic and retain the result
    proc = subprocess.Popen([
        'curl',
        '-X',
        'GET',
        '-H',
        'Api-Key: ' + config_data['api_key'],
        '-H',
        'Api-Username: ' + config_data['api_username'],
        '-H',
        'Content-Type: application/json',
        config_data['base_url'] + '/t/{'+str(options.topic)+'}.json'],
        stdout=subprocess.PIPE
    )

    # read the result into a usable buffer
    output = proc.stdout.read()

    # convert the result to json
    try:
        topic_json = json.loads(output)
    except:
        print("topic " + str(options.topic) + " doesn't exist; exiting")
        sys.exit(4)


    # extract the post ID from the topic json
    post_id = topic_json['post_stream']['posts'][0]['id']
    category_id = topic_json['category_id']
    if(options.category):
        if((category_id is None) or (int(options.category) != int(category_id))):
            print("topic does not match the category specified")
            print("exiting without pulling topic")
            sys.exit()
    deleted_at = topic_json['deleted_at']
    if(deleted_at):
        print("post deleted: not pulled from discourse")
        sys.exit()

    autoname = topic_json['post_stream']['posts'][0]['topic_slug'] + \
        '-' + str(options.topic) + '.md'

    # compute the output filename
    if(options.autoname):
        outfile_name = autoname;
    else:
        outfile_name = options.filename
    
    # if user requested the intermediate topic json, specified filename
    if( options.topic_json_file ):
        f2 = open(options.topic_json_file, "w")
        f2.write(str(topic_json))
        f2.close()

# get post, convert it to markdown, and write it to the specified filename
if( options.get ):

    # is this a github pull?
    if( options.github ):
        proc = subprocess.Popen([
            'git',
            'fetch',
            '--all'],
            stdout=subprocess.PIPE
        )
        proc = subprocess.Popen([
            'git',
            'checkout',
            'origin/master',
            '--',
            outfile_name],
            stdout=subprocess.PIPE
        )
        
    else:
    
        # read the post using the api, retaining the return value
        proc2 = subprocess.Popen([
            'curl',
            '-X',
            'GET',
            '-H',
            'Api-Key: ' + config_data['api_key'],
            '-H',
            'Api-Username: ' + config_data['api_username'],
            '-H',
            'Content-Type: application/json',
            config_data['base_url'] + '/posts/{'+str(post_id)+'}.json'],
                                 stdout=subprocess.PIPE
        )

        # copy the return value to a suitable buffer
        output2 = proc2.stdout.read()
        
        # convert the returned post to json
        post_json = json.loads(output2)
        
        # if user requested intermediate post json, write it to the specified filename
        if( options.json_file ):
            f2 = open(options.json_file, "w")
            f2.write(str(post_json))
            f2.close()
            
            # extract the article markdown from the json output
            raw = post_json['raw']
            
            # write the article markdown to the specified filename
            f = open(outfile_name, "w")
            f.write(str(raw))
            f.close()

    # exit now, as this run is finished
    sys.exit(0)

# put a (presumably edited) article back into discourse, updating the post
if( options.put ):
    
    # load and convert the specified markdown file
    f = open(outfile_name, "r")
    markdown = f.read()

    # is this a github push?
    if( options.github ):
        proc = subprocess.run([
            'git',
            'add',
            os.getcwd() + '/' + outfile_name],
            stdout=subprocess.PIPE
        )
    
        proc = subprocess.Popen([
            'git',
            'commit',
            '-m',
            '"' + outfile_name + " updated"],
            stdout=subprocess.PIPE
        )
        proc = subprocess.Popen([
            'git',
            'push'],
            stdout=subprocess.PIPE
        )
        
    else:
        # pad the markdown to 9000 chars to avoid discourse bug
        outstr = markdown.ljust(9000)
        
        # create a dictionary buffer for the markdown
        data = {}
        
        # place the markdown against a key called "raw" (the json key reqd by discourse)
        data["raw"] = outstr
        
        # open a temporary json file to store the markdown as json
        f = open("foo.json", "w")
        
        # convert the markdown to json and store it in the temp file
        f.write(json.dumps(data))
        
        # close the temp file for completeness
        f.close()
        
        # if user requested intermediate post json, write it to the specified filename
        if( options.json_file ):
            f2 = open(options.json_file, "w")
            f2.write(str(post_json))
            f2.close()

            # set the url and auth data as read from the yaml config file
            url = config_data['base_url'] + '/posts/{'+str(post_id)+'}.json'
            apikey = 'Api-Key: ' + config_data['api_key']
            apiusername = 'Api-Username: ' + config_data['api_username']

            # use the curl command to re-post the markdown into discourse
            response = subprocess.check_output([
                'curl',
                '-X',
                'PUT',
                url,
                '-H',
                apikey,
                '-H',
                apiusername,
                '-H',
                'Content-Type: application/json',
                '-d',
                '@foo.json']
            )

            # remove the temporary json file
            os.remove("foo.json")
            
    # exit now, as this run is finished
    sys.exit(0)

# create a new article in discourse
if( options.new ):
    
    # load and convert the specified markdown file
    f = open(options.filename, "r")
    markdown = f.read()
    
    # pad the markdown to 9000 chars to avoid discourse bug
    outstr = markdown.ljust(9000)

    # create a dictionary buffer for the markdown
    data = {}
    
    # place the markdown against a key called "raw" (the json key required by discourse)
    data["raw"] = outstr
    data["title"] = options.topic_title
    data["category"] = 5

    # open a temporary json file to store the markdown as json
    f = open("foo.json", "w")

    # convert the markdown to json and store it in the temp file
    f.write(json.dumps(data))

    # close the temp file for completeness
    f.close()

    # set the url and auth data as read from the yaml config file
    url = config_data['base_url'] + '/posts.json'
    apikey = 'Api-Key: ' + config_data['api_key']
    apiusername = 'Api-Username: ' + config_data['api_username']

    # use the curl command to re-post the markdown into discourse
    response = subprocess.check_output([
        'curl',
        '-X',
        'POST',
        url,
        '-H',
        apikey,
        '-H',
        apiusername,
        '-H',
        'Content-Type: application/json',
        '-d',
        '@foo.json']
    )

    # exit now, as this run is finished
    sys.exit(0)



